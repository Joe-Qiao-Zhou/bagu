# IO模型

- 输入操作的两个阶段：等待数据到达+从内核向进程复制数据

  - 数据到达后鲜卑复制到内核中的某个缓冲区，再从内核缓冲区复制到进程缓冲区

- IO模型

  1. 阻塞式IO：进程被阻塞，直到数据复制完
  2. 非阻塞式IO：进程可以继续执行，但需要不断执行系统调用获知IO是否完成，称为**轮询polling**
  3. IO复用：一个线程通过记录I/O流的状态来同时管理**多个I/O**
  4. 信号驱动IO：进程使用sigaction系统调用，等待数据时继续执行，直到数据准备好接收到SIGIO信号，开始接收数据
  5. 异步IO：直到IO完成后才通知进程

  ![image-20220509212421632](C:\Users\91494\AppData\Roaming\Typora\typora-user-images\image-20220509212421632.png)

# IO复用

- select
  - bitmap每一位表示对应文件描述符是否有数据，通过fd数组截取长度
  - 将bitmap拷贝到内核态，交给内核监听，阻塞直到有数据，对应位置1，返回给用户态
  - 缺点
    1. bitmap最大为1024
    2. 状态之间切换有消耗
    3. bitmap每次都要置0
    4. 返回给用户态后还需要遍历才能知道哪里有数据
  - 优点：实时性更高；可移植性更好，几乎所有主流平台都支持
- poll
  - 使用pollfd结构体替代bitmap，包括fd、表示事件类型的events和表示事件状态的revents，解决了select的缺点1和3
- epoll
  - 使用epfd代替pollfd，只有fd和events没有revents，不需要状态切换，可理解为两态共享该结构，通过重排置位，有数据的就去首部